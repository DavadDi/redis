Welcome to the Naive Disk Store.  It is an attempt to see if a really
stupidly-simple disk-backed store has any hope of working with Redis.  The
intended use case is for a redis instance that stores a lot of data, but
with a relatively small active set of keys.  

NDS is implemented by persisting every change to a key to an on-disk
database, through a periodic "flush" of all keys that have changed
(controlled by the same logic as RDB dumps).  Every time a key isn't
available in memory, the on-disk database is checked to see if the key
exists.

The concept is that you can keep memory usage of your redis instance under
control by setting maxmemory (with an allkeys-lru eviction policy,
preferably) and as memory is required, keys that haven't been recently used
get evicted from memory.  When they're needed again in the future, however,
they're available on disk.

There are a few "side benefits" to using NDS.  They're not the reason it was
written, but they're useful anyway.  Whether they're worth it for your
use-case is up to you.

* Very, very short "startup" time.  Instead of having to load a large RDB or
  AOF into memory, the redis instance can immediately start serving
  requests.  The performance will be poor until the popular keys are all
  in-memory, but often slow operation is better than no operation.

* Disk-efficient, near-real-time persistence.  Disk space usage isn't
  significantly more than an RDB file, and you never have to trigger a
  rewrite or a complete dump -- and yet, you still get up-to-date
  persistence.

Conversely, there are a few downsides:

* Slow performance for a while after startup.  Until the keys you're working
  on are in memory (either by preloading, or just through cache misses
  pulling the important keys in), the first time each key accessed after
  startup there is a hit to disk to go get the key.

* If your "hot set" of keys is larger than the amount of memory you choose
  to allow Redis to use, performance will suck.  This shouldn't be news to
  anyone, though.  NDS is awesome, but it isn't magic.  You may just need to
  give it more memory.


DEPLOYING

If you've checked out my git repo, you can just build it as normal. 
Otherwise, you'll have to patch whatever source tree you're using with the
changes from my git repo.

There are three new configuration parameters available:

* `nds` -- set this to `yes` to enable NDS.  This will disable AOF and RDB
  persistence (including reading those files at startup -- you will need to
  replicate into NDS to get an existing dataset loaded).

* `nds-preload` -- set this to `yes` to tell NDS to load all keys off disk
  at startup.  This will slow down other clients considerably, although it
  doesn't block other clients completely.  By enabling this option, you get
  regular Redis performance (after the preload is complete), but with NDS'
  persistence model.  You probably shouldn't enable this option if you're
  trying to keep your memory usage under control.

Once NDS is enabled, you want to change the value of the `save` parameter to
something really, really low, because saving the changed keys to disk
doesn't cost very much at all.  I use `5 1 1 5` usually, just because I like
the symmetry, but `1 1` is equivalent to AOF's "fsync every second" mode,
and `1 0` is more-or-less "write 'em out as quick as you can", although we
don't guarantee that keys will be persistent on disk when the command
completes.

There are also a few options you want to tweak, if you want to use NDS for
its ability to maintain only a subset of keys in memory:

* `maxmemory` -- assuming you want to use NDS to keep your redis memory
  usage under control, set `maxmemory` to whatever you want to keep your
  memory usage to.  You could just use NDS for quick startup and frequent,
  IO-efficient persistence, in which case you can leave `maxmemory` alone.

* `maxmemory-policy` -- you want to set this to `allkeys-lru`, to ensure
  that the most frequently used keys are kept in memory and the least-used
  keys end up living on disk.

* `maxmemory-samples` -- Bumping this up somewhat will help to select
  "better" keys for eviction.  I use `15` here, and it doesn't appear to
  kill performance badly.

* `save` -- set this nice and low, because a flush doesn't cost much.  You
  could go with `1 1` to flush all changes every second.  I use `5 1 1 5` by
  default, because I like the symmetry.

To fill your NDS redis instance from an existing dataset, you need to
replicate your data from another redis instance.  By firing up your NDS
redis on a local address/port, replicating from the existing "live" redis,
then killing the live redis, changing the NDS redis config to use the live
address/port/socket/whatever, and then starting it again, you can get the
cutover downtime to a few seconds if you script it.


MANAGEMENT

There are a few commands that have been added to the redis command set:

* `NDS FLUSH` -- Use this if you wish to trigger a manual flush of all keys
  (I can't imagine why you'd need to, but it's there if you want it).

* `NDS SNAPSHOT` -- Take a copy of all of the NDS data files, so you can get
  consistent disk backups of all your redis data.  The snapshot will be
  stored in a directory underneath your Redis data directory named,
  unimaginatively enough, "snapshot".

* `NDS CLEARSTATS` -- If you want to nuke the cache hit/miss numbers, this
  is how to do it.

* `NDS PRELOAD` -- Trigger a "manual" preload.  This is useful if you want
  to suddenly get everything into memory, but didn't have it set in the
  config file.

There is also a new section in the `INFO` output, for NDS statistics.  It'll
show up when you run `INFO`, and can be produced on its own with `INFO NDS`. 
It has the following keys:

* `nds_enabled` (boolean) -- Whether or not NDS is enabled.

* `nds_preload` (boolean) -- Whether or not the "preload" function of NDS
  has been triggered (either at startup, by setting `nds-preload yes` in the
  config file, or at runtime, by running `NDS PRELOAD`).

* `nds_keycache` (boolean) -- Whether or not the NDS keycache feature was
  enabled in the config file, with `nds-keycache yes`.

* `nds_cache_hits` (integer) -- The number of times a request for a key was
  satisfied out of memory.

* `nds_cache_misses` (integer) -- The number of times NDS has had to go to
  disk to satisfy a request for a key.

* `nds_cache_hit_rate` (floating-point percentage) -- The percentage of
  requests for keys that have been satisfied from memory.  Just an
  easier-on-the-eyes version of the previous two metrics.

* `nds_usec` (integer) -- The number of microseconds that have been spent in
  "NDS overhead" since the server process was started.  As close as I can
  make it, it is a measurement of how much extra time Redis has had to take
  in order to use NDS, over and above the time that would have been spent
  had NDS been disabled.

* `nds_dirty_keys` (integer) -- The number of keys that have been
  modified, but aren't yet in a background flush.  If this number gets
  large, it indicates that NDS isn't able to keep up with the current rate
  of changes.

* `nds_flushing_keys` (integer) -- The number of keys that are currently
  being flushed by a background process.  If this number keeps growing over
  time, you're either failing flushes (see `nds_flush_failure`, below), or
  NDS isn't keeping up with the rate of changes (in which case,
  `nds_dirty_keys` should also be going up at the same rate).

* `nds_flush_success` (integer) -- The number of successful flushes.  Not
  generally very interesting in and of itself.

* `nds_flush_failure` (integer) -- The number of flushes that have failed
  for some reason.  If this number goes up over time, you've got a bit of a
  problem.  If this number goes up and `nds_flush_success` *isn't*, then
  you're not flushing keys to disk at all and you have a *major* problem.

* `nds_preload_in_progress` (boolean) -- Are we currently preloading all
  keys?  Should only be true (`1`) for a short period of time, and only on
  startup (or after `NDS PRELOAD`).  If your system's running slowly all
  of a sudden, and this is `1`, then someone's triggered the preload.

* `nds_preload_complete` (boolean) -- Set to true (`1`) if the dataset has
  been preloaded.  More informational than anything.

* `nds_snapshot_pending` (boolean) -- Tells you if the system is waiting on
  a flush to complete before a snapshot can be taken.  If you're using `NDS
  SNAPSHOT` for backups, this key (and `nds_snapshot_in_progress`) should be
  monitored so you know when the snapshot is complete.
  
* `nds_snapshot_in_progress` (boolean) -- True (`1`) if the current flush is
  also taking a snapshot.

* `nds_child_pid` (integer) -- The process ID of the child which is
  currently performing NDS background tasks (flush to disk, snapshotting),
  or `-1` if no child currently exists.  Useful for checking who belongs to
  who, and also to see if NDS even *has* a background process running at
  present.


DITCHING NDS

If you want to move away from NDS, here is the simplest way:

* Disable all access to the Redis instance.

* `SAVE` -- this will create a `dump.rdb` file.

* `SHUTDOWN` -- stop Redis.

* Disable NDS in the config file by setting `nds no`.

* Start Redis again.  Since NDS is now disabled, Redis will read all data
  into memory from the `dump.rdb` file.

You can reduce the amount of downtime by using AOF instead of RDB, too.


NDS-SPECIFIC CONFIGURATION PARAMETERS

There are a few new parameters which you can set in your redis.conf to
enable and control the NDS system:

* `nds` (boolean; default `no`) -- Whether or not NDS is actually enabled. 
  If you're running the NDS patchset in the first place, then presumably you
  usually want to set this to `yes`, however it is useful if you run huge
  fleets of Rediises to have a single build for all instances, and not all
  of them run NDS (the horror!), you can use this option to disable it.

* `nds-watermark` (integer (with optional suffix); default `0`) -- If set to
  a value greater than `0`, NDS will *try* to keep memory usage under this
  many bytes.  Redis won't refuse writes if memory usage exceeds this value,
  but it will immediately attempt to flush dirty keys, and will discard keys
  from memory to return memory usage to below this point.
  
  This "high water mark" feature is very similar in concept to "soft" and
  "hard" disk quotas.  By triggering a flush before we hit `maxmemory` (and
  hence start denying writes), the system can try to clear out dirty keys
  before it runs out of memory completely.  You should set `nds-watermark`
  to an amount of memory that the system can comfortably accommodate
  (including memory used by other processes, and a suitable disk cache),
  while `maxmemory` should be set to a value which, if exceeded, would cause
  system instability (OOM kills) or unacceptable performance degradation
  (excessive swapping).

* `nds-preload` (boolean; default `no`) -- Should we preload all data into
  memory?  Preloading is a means of loading the full set of keys into memory
  from disk on startup, whilst also servicing client requests.  This gives
  you, in many ways, the best of both worlds.  You get the performance of a
  fully in-memory data set, with quick startup and frequent persistence to
  disk.  On the downside, you will need to have enough memory to store your
  entire dataset, or preloading won't be particularly effective.

* `nds-keycache` (boolean; default `no`) -- Should we cache the names of all
  keys that are on disk in memory?  By default, when a command is run on a
  key that doesn't exist *at all*, (say pushing to an empty list, or a GET
  on a non-existent key) NDS has to go to disk to satisfy itself that they
  key doesn't exist.  This read from disk slows down request rates, as it's
  done synchronously (it blocks all other requests in the queue).  Thus, in
  a database that sees a lot of operations on non-existent keys (such as a
  use case that uses the existence or otherwise of a key as useful
  information) performance can slow to a crawl as NDS continually looks to
  disk for keys that aren't expected to even exist.
  
  In this situation, the "keycache" can be a huge performance benefit.  The
  way it works is simple: all key *names* are read off disk at startup, and
  kept in memory.  Whenever the set of keys on disk changes, the list in
  memory is updated.  Thus, instead of having to go to disk to answer the
  question, "does this key exist?", we can just check memory.  The downside
  of this is twofold:
  
  * Slightly slower startup (it isn't too bad, since reading just the key
    names off disk is pretty quick); and
  
  * The memory usage of storing *every* key name in memory can become
    significant when dealing with particularly large datasets.
  

TODO

NDS is very new, and shouldn't be relied upon for anything really important. 
There may be some pretty serious bugs in the code that haven't been found
yet.  If you're not comfortable digging into the code to find the bug and
submit a patch, you *probably* don't want to be deploying this thing right
now.

Here are the list of things that are known deficiencies in the code, as
compared to "stock" Redis:

* Keys must be between 1 and 511 octets in length, inclusive.  This is a
  limitation in MDB, and isn't something that can be easily extended.  If
  you attempt to set a key outside of these limits, Redis will return an
  error.

And here are features that might be useful to implement, but aren't bugs as
such:

* An `nds-sync` mode would be cute (but slow as molasses) -- instead of
  forking children to write dirty keys to disk, instead write the change to
  disk immediately.  Ouch.  An alternative would be to use an AOF-style journal
  (probably with fsync=immediate) to keep a record of those changes that
  haven't get been flushed to disk (although this would need to set keys,
  rather than (say) increment them, to avoid problems when a key got written
  to disk but the flush didn't *complete*).
