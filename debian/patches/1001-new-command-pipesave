From ec80382af9c1641dbcbaa712b08b9140d4dcc4de Mon Sep 17 00:00:00 2001
From: Matt Palmer <mpalmer@hezmatt.org>
Date: Wed, 30 May 2012 18:39:32 +1000
Subject: [PATCH 1001/1010] New command: pipesave

Allows you to specify a command to run (via the config file *only*, to
prevent people from running arbitrary code on your machine via redis), which
will be invoked and fed the contents of an RDB dump file.  Useful for taking
offsite backups (say, to S3 or a centralised backup server) or a periodic
replication mechanism when you don't want (or don't have the available
memory) to run twice as many redis instances everywhere.

Ported to 2.6.0-rc3 from 2.4.9.
---
 redis.conf   |   7 +++++
 src/config.c |   8 +++++
 src/config.h |   5 +++
 src/db.c     |   8 +++++
 src/rdb.c    | 100 ++++++++++++++++++++++++++++++++++++++++++++++++-----------
 src/rdb.h    |   1 +
 src/redis.c  |   2 ++
 src/redis.h  |   2 ++
 8 files changed, 115 insertions(+), 18 deletions(-)

diff --git a/redis.conf b/redis.conf
index f5e15f6..4bbc92e 100644
--- a/redis.conf
+++ b/redis.conf
@@ -126,6 +126,13 @@ rdbchecksum yes
 # The filename where to dump the DB
 dbfilename dump.rdb
 
+# When a client requests PIPESAVE, Redis will fork, popen(3) whatever 
+# you have defined in pipesavecommand, and spit an RDB dump down its 
+# throat.  For security reasons, this configuration knob must be 
+# supplied in this file (if it is supplied at all) and cannot be 
+# overriden at runtime with CONFIG SET.
+#pipesavecommand "/usr/bin/whatever \"blah blah\""
+
 # The working directory.
 #
 # The DB will be written inside this directory, with the filename specified
diff --git a/src/config.c b/src/config.c
index 9765d29..4bb47cb 100644
--- a/src/config.c
+++ b/src/config.c
@@ -275,6 +275,9 @@ void loadServerConfigFromString(char *config) {
             server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-value") && argc == 2) {
             server.hash_max_ziplist_value = memtoll(argv[1], NULL);
+        } else if (!strcasecmp(argv[0],"pipesavecommand") && argc == 2) {
+            zfree(server.pipesavecommand);
+            server.pipesavecommand = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"list-max-ziplist-entries") && argc == 2){
             server.list_max_ziplist_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"list-max-ziplist-value") && argc == 2) {
@@ -797,6 +800,11 @@ void configGetCommand(redisClient *c) {
         addReplyBulkCString(c,buf);
         matches++;
     }
+    if (stringmatch(pattern,"pipesavecommand",0)) {
+        addReplyBulkCString(c,"pipesavecommand");
+        addReplyBulkCString(c,server.pipesavecommand);
+        matches++;
+    }
     if (stringmatch(pattern,"maxmemory-policy",0)) {
         char *s;
 
diff --git a/src/config.h b/src/config.h
index 28ef37d..2f09029 100644
--- a/src/config.h
+++ b/src/config.h
@@ -52,6 +52,11 @@
 #define aof_fsync fsync
 #endif
 
+/* Does your popen(3) support the 'e' flag? */
+#ifdef __linux__
+#define HAVE_POPEN_MODE_E 1
+#endif
+
 /* Byte ordering detection */
 #include <sys/types.h> /* This will likely define BYTE_ORDER */
 
diff --git a/src/db.c b/src/db.c
index e65106a..c0d3eed 100644
--- a/src/db.c
+++ b/src/db.c
@@ -322,6 +322,14 @@ void shutdownCommand(redisClient *c) {
     addReplyError(c,"Errors trying to SHUTDOWN. Check logs.");
 }
 
+void pipesaveCommand(redisClient *c) {
+    if (rdbPipesaveBackground(server.pipesavecommand) == REDIS_OK) {
+        addReplyStatus(c,"Background pipesave started");
+    } else {
+        addReply(c,shared.err);
+    }
+}
+
 void renameGenericCommand(redisClient *c, int nx) {
     robj *o;
     long long expire;
diff --git a/src/rdb.c b/src/rdb.c
index 90c2ea0..be0792b 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -609,12 +609,24 @@ int rdbSave(char *filename) {
     rio rdb;
     uint64_t cksum;
 
-    snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
-    fp = fopen(tmpfile,"w");
-    if (!fp) {
-        redisLog(REDIS_WARNING, "Failed opening .rdb for saving: %s",
-            strerror(errno));
-        return REDIS_ERR;
+    if (filename[0] == '|') {
+#ifdef HAVE_POPEN_MODE_E
+        fp = popen(filename+1, "we");
+#else
+        fp = popen(filename+1, "w");
+#endif
+        if (!fp) {
+            redisLog(REDIS_WARNING, "Failed saving the DB via pipe: %s", strerror(errno));
+            return REDIS_ERR;
+        }
+    } else {
+        snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
+        fp = fopen(tmpfile,"w");
+        if (!fp) {
+            redisLog(REDIS_WARNING, "Failed opening .rdb for saving: %s",
+                strerror(errno));
+            return REDIS_ERR;
+        }
     }
 
     rioInitWithFile(&rdb,fp);
@@ -629,7 +641,11 @@ int rdbSave(char *filename) {
         if (dictSize(d) == 0) continue;
         di = dictGetSafeIterator(d);
         if (!di) {
-            fclose(fp);
+            if (filename[0] == '|' ) {
+                pclose(fp);
+            } else {
+                fclose(fp);
+            }
             return REDIS_ERR;
         }
 
@@ -663,25 +679,38 @@ int rdbSave(char *filename) {
     /* Make sure data will not remain on the OS's output buffers */
     fflush(fp);
     fsync(fileno(fp));
-    fclose(fp);
+    if (filename[0] == '|') {
+        if (pclose(fp) < 0) {
+            redisLog(REDIS_WARNING, "Save to pipe failed: %s", strerror(errno));
+            return REDIS_ERR;
+        }
+        redisLog(REDIS_NOTICE,"DB saved to command '%s'", filename+1);
+    } else {
+        fclose(fp);
 
-    /* Use RENAME to make sure the DB file is changed atomically only
-     * if the generate DB file is ok. */
-    if (rename(tmpfile,filename) == -1) {
-        redisLog(REDIS_WARNING,"Error moving temp DB file on the final destination: %s", strerror(errno));
-        unlink(tmpfile);
-        return REDIS_ERR;
+        /* Use RENAME to make sure the DB file is changed atomically only
+         * if the generate DB file is ok. */
+        if (rename(tmpfile,filename) == -1) {
+            redisLog(REDIS_WARNING,"Error moving temp DB file on the final destination: %s", strerror(errno));
+            unlink(tmpfile);
+            return REDIS_ERR;
+        }
+        redisLog(REDIS_NOTICE,"DB saved on disk");
     }
-    redisLog(REDIS_NOTICE,"DB saved on disk");
     server.dirty = 0;
     server.lastsave = time(NULL);
     server.lastbgsave_status = REDIS_OK;
     return REDIS_OK;
 
 werr:
-    fclose(fp);
-    unlink(tmpfile);
-    redisLog(REDIS_WARNING,"Write error saving DB on disk: %s", strerror(errno));
+    if (filename[0] == '|') {
+        pclose(fp);
+        redisLog(REDIS_WARNING,"Write error saving DB to pipe: %s", strerror(errno));
+    } else {
+        fclose(fp);
+        unlink(tmpfile);
+        redisLog(REDIS_WARNING,"Write error saving DB on disk: %s", strerror(errno));
+    }
     if (di) dictReleaseIterator(di);
     return REDIS_ERR;
 }
@@ -720,6 +749,41 @@ int rdbSaveBackground(char *filename) {
     return REDIS_OK; /* unreached */
 }
 
+int rdbPipesaveBackground(char *command) {
+    pid_t childpid;
+    char *pipecommand;
+
+    if (!command || strlen(command) < 1) {
+        redisLog(REDIS_WARNING,"Cannot PIPESAVE without a configured pipesavecommand");
+        return REDIS_ERR;
+    }
+
+    if ((childpid = fork()) == 0) {
+        /* Child */
+        if (server.ipfd > 0) close(server.ipfd);
+        if (server.sofd > 0) close(server.sofd);
+        pipecommand = zmalloc(strlen(command) + 2);
+        snprintf(pipecommand, strlen(command) + 2, "|%s", command);
+
+        if (rdbSave(pipecommand) == REDIS_OK) {
+            _exit(0);
+        } else {
+            _exit(1);
+        }
+    } else {
+        /* Parent */
+        if (childpid == -1) {
+            redisLog(REDIS_WARNING,"Can't pipesave in background: fork: %s",
+                strerror(errno));
+            return REDIS_ERR;
+        }
+        redisLog(REDIS_NOTICE,"Background pipesave started by pid %d",childpid);
+        updateDictResizePolicy();
+        return REDIS_OK;
+    }
+    return REDIS_OK; /* unreached */
+}
+
 void rdbRemoveTempFile(pid_t childpid) {
     char tmpfile[256];
 
diff --git a/src/rdb.h b/src/rdb.h
index 37f4474..78476e2 100644
--- a/src/rdb.h
+++ b/src/rdb.h
@@ -75,6 +75,7 @@ int rdbSaveObjectType(rio *rdb, robj *o);
 int rdbLoadObjectType(rio *rdb);
 int rdbLoad(char *filename);
 int rdbSaveBackground(char *filename);
+int rdbPipesaveBackground(char *command);
 void rdbRemoveTempFile(pid_t childpid);
 int rdbSave(char *filename);
 int rdbSaveObject(rio *rdb, robj *o);
diff --git a/src/redis.c b/src/redis.c
index 46915c1..99e167f 100644
--- a/src/redis.c
+++ b/src/redis.c
@@ -206,6 +206,7 @@ struct redisCommand redisCommandTable[] = {
     {"ping",pingCommand,1,"r",0,NULL,0,0,0,0,0},
     {"echo",echoCommand,2,"r",0,NULL,0,0,0,0,0},
     {"save",saveCommand,1,"ars",0,NULL,0,0,0,0,0},
+    {"pipesave",pipesaveCommand,1,"ars",0,NULL,0,0,0,0,0},
     {"bgsave",bgsaveCommand,1,"ar",0,NULL,0,0,0,0,0},
     {"bgrewriteaof",bgrewriteaofCommand,1,"ar",0,NULL,0,0,0,0,0},
     {"shutdown",shutdownCommand,-1,"ar",0,NULL,0,0,0,0,0},
@@ -1102,6 +1103,7 @@ void initServerConfig() {
     server.pidfile = zstrdup("/var/run/redis.pid");
     server.rdb_filename = zstrdup("dump.rdb");
     server.aof_filename = zstrdup("appendonly.aof");
+    server.pipesavecommand = NULL;
     server.requirepass = NULL;
     server.rdb_compression = 1;
     server.rdb_checksum = 1;
diff --git a/src/redis.h b/src/redis.h
index 7cde4eb..0e1c504 100644
--- a/src/redis.h
+++ b/src/redis.h
@@ -528,6 +528,7 @@ struct redisServer {
     time_t rdb_save_time_start;     /* Current RDB save start time. */
     int lastbgsave_status;          /* REDIS_OK or REDIS_ERR */
     int stop_writes_on_bgsave_err;  /* Don't allow writes if can't BGSAVE */
+    char *pipesavecommand;          /* Program to fork to receive an RDB over a pipe */
     /* Propagation of commands in AOF / replication */
     redisOpArray also_propagate;    /* Additional command to propagate. */
     /* Logging */
@@ -1002,6 +1003,7 @@ void lastsaveCommand(redisClient *c);
 void saveCommand(redisClient *c);
 void bgsaveCommand(redisClient *c);
 void bgrewriteaofCommand(redisClient *c);
+void pipesaveCommand(redisClient *c);
 void shutdownCommand(redisClient *c);
 void moveCommand(redisClient *c);
 void renameCommand(redisClient *c);
-- 
1.7.11.1

